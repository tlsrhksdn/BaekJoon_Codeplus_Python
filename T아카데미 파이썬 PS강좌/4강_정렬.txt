3 1 2 8 5 7 6 4 의 숫자 집합이 있다

선택 정렬

1 2 7 8 4 5 3 6
시간복잡도 : O((N(N+1)/2)) = O(N**2)

버블 정렬

1 2 3 7 5 6 4 8 
시간복잡도 : O(N(N+1)/2)) = O(N**2)

위의 두 정렬은 코테에서 거의 사용하지 않음
웬만하면 O(log(N))의 시간복잡도의 정렬을 사용한다.

퀵 정렬

3을 기준

(1 2) 3 (8 5 7 6 4)

T(N) = 2T(N/2) + N
     = 2(T(N/4)+N/2) + N
     = 4T(N/4) + N + N = 4T(N/4) + 2N
     ......
     = 2**k*T(N/(2**k)) + kN
     2**k ~= N, NT(1) + 2Nlog2N

따라서 시간복잡도: O(ㅜlogN)

특정 상황에서는 시간복잡도가 O(N**2)가 된다

병합 정렬(Merge Sort)

3 2 8 1 / 5 7 6 4

3 2 / 8 1 / 5 7 / 6 4

2 3 / 1 8 / 7 5 / 4 6

->two pointer를 이용해 정렬

T(N) = T(N/2)*2 + N

Quick Sort와의 차이점: 항상 시간복잡도가 O(NlogN)이다.

단점: 배열을 계속 할당하므로 메모리 용량이 많이 든다.

Radix Sort

